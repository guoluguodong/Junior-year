OpenPGP is the most widely used email encryption standard. It is defined by the OpenPGP Working Group of the Internet Engineering Task Force (IETF) as a Proposed Standard in [RFC 4880](https://tools.ietf.org/html/rfc4880). OpenPGP was originally derived from the PGP software, created by [Phil Zimmermann](https://philzimmermann.com/).

[RFC 4880 - OpenPGP Message Format (ietf.org)](https://datatracker.ietf.org/doc/html/rfc4880#section-2.1)



## 摘要：

​        作者们提出了一套针对OpenPGP规范和实现的攻击方法，这些攻击可以完全恢复用户的私钥。这些攻击利用了加密私钥数据包内部不同字段之间缺乏加密绑定的漏洞，这些字段包括密钥算法标识符、明文公共参数和加密的私有参数。这使得攻击者可以覆写OpenPGP密钥数据包中的某些字段，从而执行跨算法攻击，例如，使用户的软件误解ECC私钥为DSA密钥。它还允许攻击者用敌对选择的参数替换合法的公共参数，例如，允许他们选择DSA组。我们将这类攻击称为密钥覆写（KO）攻击。

​        我们对不同OpenPGP库对KO攻击的脆弱性进行了详细分析，特别是在某些情况下，库执行的额外密钥验证步骤实际上允许变体攻击。我们还评估了在反映不同威胁模型的特定OpenPGP基础应用程序的上下文中，KO攻击的适用性。

​        最后，我们解释了如何在OpenPGP规范级别完全防止KO攻击（并使密钥验证过时），方法是扩展现有的使用AEAD方案保护密钥数据包的提议，将所有与安全相关的公共字段包含为关联数据。

## 1 INTRODUCTION

​        OpenPGP是一种最初在20世纪90年代开发的规范，用于保护通用电子通信和数据。如今，该协议主要以电子邮件加密而闻名，但它也广泛用于保护存储和通过签名进行数据认证。从1999年的开始，一直到现在的.OpenPGP在安全性和可用性方面受到了严重的批评。安全问题源于所使用的数据格式的复杂性，以及其依赖的加密算法和构造被认为是过时的，且无法证明其安全性。除了这些纯技术问题外，使用OpenPGP保护电子邮件对于普通用户来说可能会带来重大的可用性问题。然而，现在有各种电子邮件应用程序通过“在后台”使用OpenPGP，提供了更流畅的用户体验，而且有一个活跃的开发者、库和应用程序使用该规范的生态系统。事实上，OpenPGP仍然是最广泛使用的电子邮件加密规范之一，而且正在进行持续的努力来指定它的新版本、，目标是更新其底层的加密原语。这种持续的相关性证明了对OpenPGP的持续分析是有道理的。

​        传统上，对电子邮件系统的分析是在一个弱威胁模型中进行的，其中与邮件服务器的交互仅限于下载和发送消息，远程方不能直接与加密软件通信，而该软件只在本地用于解密/加密或签名/验证一些电子邮件。然而，OpenPGP的使用场景已经发展，过去20年的应用场景已经发生了变化。特别是，我们现在看到云存储的广泛使用，浏览器内和服务器提供的加密服务，以及这些服务的自动化加密处理。因此，过去合理的建模假设需要被挑战，安全需求需要重新评估。此外，OpenPGP标准非常灵活，没有针对保护电子邮件的特定用例。因此，OpenPGP规范及其实现不能满足传统电子邮件部署相关的弱对手模型，而应该旨在防御标准的攻击类别。

​        在这篇论文中，我们关注的是将加密的私有OpenPGP密钥存储在不安全的存储中的后果，并展示了一种攻击者如何在具有对应加密密钥包的写入权限的情况下，篡改它并在使用修改后的密钥包时提取私钥。我们还概述了一种概念上更简单的攻击，该攻击允许访问已发送的消息。不安全存储的威胁模型与一些使用OpenPGP的现代云基础应用程序相关。例如，ProtonMail允许用户通过在ProtonMail 服务器上以加密形式存储每个用户的私钥来从多个设备访问他们的数据，而加密密码短语对服务器来说是未知的。

​      所谓的密钥覆写（KO）攻击向量并不新鲜：早在2001年，Klíma和Rosa就展示了如何以这种方式针对DSA和RSA密钥。Attack on Private Signature Keys of the OpenPGP Format, PGP(TM) Programs and Other Applications Compatible with OpenPGP. By Vlastimil Klima and Tomas Rosa

​        他们的工作导致一些OpenPGP的实现引入了密钥验证，以及规范变更以防止对RSA密钥的攻击。我们在OpenPGP的现代应用场景中重新审视了的核心思想，例如，服务器可能具有执行KO攻击所需的能力，并应被视为不受信任。我们对KO攻击进行了系统性的探索，并展示了它们如何被用于提取任何支持的算法（即EdDSA、ECDSA、ECDH、RSA、DSA和ElGamal）的私钥。广泛的适用性源于跨算法攻击：OpenPGP规范并未包含允许系统性检测某些类型的私钥数据包损坏的加密机制，并且并不要求私钥与其类型有加密绑定。这意味着任何密钥类型的安全性都降低到了具有可互换私有参数的最弱密钥类型的安全性。具体来说，由于我们为DSA和ElGamal密钥提供了高效的攻击，我们获得了对其他离散对数密钥类型ijh，即EdDSA、ECDSA和ECDH密钥的高效攻击。我们还提供了针对RSA的特定攻击，包括签名和加密设置；这些攻击需要使用非CRT-based的私钥操作。我们强调，KO攻击假设用户在不断检查自己密钥的指纹时并不小心。（例如，如果他们可以用用户的密码短语解密密钥，他们就信任这些密钥）

​        密钥指纹在网络安全领域有着广泛的应用，它是基于公钥加密系统的一种简短、唯一标识1。具体来说，密钥指纹是一种数字摘要，用于验证公钥的完整性和身份。它是从公钥生成的一个较短的字符串或数字序列，这个过程通常通过哈希函数实现。

​        如上所述，一些OpenPGP库在使用密钥之前会进行密钥验证步骤。这些步骤并未在OpenPGP规范中明确指定，因此它们既取决于实现方式，也取决于特定的算法。原则上，正确的密钥验证可以防止我们的攻击，因此我们评估了不同OpenPGP库中如何进行密钥验证以及它在多大程度上阻碍了我们的攻击。我们发现密钥验证的执行方式存在显著的差异 - 有些库没有进行任何验证，而有些库则相当彻底。然而，我们还展示了，在一些情况下，不正确的密钥验证与密钥覆写相结合，开启了我们称之为利用密钥验证的密钥覆写攻击（KOKV攻击）的新攻击类别。这种攻击也可能导致私钥的提取。

​		为了使我们的攻击具体化，我们展示了如何在OpenPGP库的上下文中实现上述攻击，这两个特定的基于OpenPGP的应用程序使用了这些库：FlowCrypt和ProtonMail。最后，我们还考虑了对KO（和KOKV）攻击的即时部署和长期对策：前者只需要求实现进行仔细的密钥验证，而后者则依赖于AEAD加密来保护私钥。在我们公开披露后，长期解决方案已被纳入OpenPGP规范的草案修订中。

​         漏洞披露。我们在2020年11月至2021年1月期间，就我们的攻击行为联系了OpenPGP工作组以及我们在论文中评审的所有库的维护者。自那时以来，OpenPGP.js和gopenpgp库已经进行了修补，以便在解密密钥的过程中执行特定于算法的参数检查。RNP也在其最近的v0.16版本中发布了全面的攻击对策。GnuPG和Sequoia没有计划进行任何更改：GnuPG的开发者认为，用户在存储或传输密钥时，不应依赖密钥加密机制的安全性（而是例如发送在适当的OpenPGP消息中加密的密钥），而Sequoia的开发者认为密钥存储攻击超出了他们的威胁模型的范围。在应用程序级别，FlowCrypt和ProtonMail都已更新，依赖于其底层OpenPGP库（OpenPGP.js和gopenpgp）的安全版本。因此，在撰写本文时，第4节描述的应用程序级别的攻击已不再可能发生。

​		相关工作。如上所述，通过覆写加密密钥来实现长期私钥妥协的想法最初在[17]中提出，其中的攻击针对RSA和DSA密钥，展示了如何破坏受害者的加密私钥，然后一旦使用被破坏的密钥进行签名，就恢复秘密指数。RSA攻击利用了OpenPGP密钥加密机制的一个弱点，OpenPGP规范在RFC 4880 [7](https://blog.csdn.net/Dontla/article/details/134290852)中被修改，通过引入新的完整性机制来修复这个问题（参见[7, Section 5.5.3]中关于字符串到密钥使用254的评论）。DSA攻击利用了一个不同的问题：攻击者不篡改加密数据，而是篡改包含在密钥包内部的明文值；[17]展示了如何使用这样一个被破坏的密钥生成的签名可能泄露DSA密钥。

​		大量其他的论文考虑了OpenPGP的不同安全方面。特别关注的是针对OpenPGP的消息加密构造的所选密文攻击（CCA）。Nguyen [26]指出，RSA和ElGamal加密都没有实现CCA安全性，因为它们都使用PKCS#1 v1.5填充[15]，这对Bleichenbacher的攻击[4](https://bulbapedia.bulbagarden.net/wiki/One-hit_knockout_move)是脆弱的。其他的工作展示了如何通过利用处理非常量时间的未经认证数据时暴露的一些预言来恢复消息[23, 25]，或者通过诱骗受害者分享看似随机的解密数据[13, 16]。EFAIL攻击[28]展示了如何通过破坏加密消息和利用应用程序对完整性检查的错误处理来泄露明文。这些工作都没有针对私钥恢复。最近的论文[6](https://zhuanlan.zhihu.com/p/342633186)关注OpenPGP实现中ElGamal加密的不安全性。有趣的是，它考虑了ElGamal算法的不同实现之间的不安全交互，而我们考虑的是跨算法而不是跨实现的攻击。

​		论文结构。我们在第2节提供了关于OpenPGP的背景信息。在第3节中，我们通过呈现理论细节并评估一些流行的OpenPGP库对我们的攻击的状态，描述了KO攻击。在第4节中，我们在OpenPGP基础应用的上下文中回顾了攻击的影响和实用性，反映了不同的威胁模型。第5节讨论了针对我们攻击的短期和长期对策，而第6节包含了我们的结束语。

## 3 PRIVATE KEY EXTRACTION VIA KEY OVERWRITING

3.3小子群攻击

在上述描述的攻击中，通过一次错误的签名，可以提取出私钥。然而，由于 𝑞′ 的尺寸较大，某些实现可能不支持被破坏的密钥，稍后我们将看到这一点。因此，我们描述了一种使用小子群攻击对 DSA 密钥的第二种攻击方法。这种技术需要数十个签名来重构完整的密钥，但它给了对手更大的灵活性。对手通过将素数 𝑝、𝑞 和子群生成器 𝑔 覆盖为某个素数 𝑝′ 和小素数 𝑞′，使得 𝑔′ 在 Z∗𝑝′ 中的阶为 𝑞′。

从生成的错误签名 (𝑟, 𝑠) 中，对手可以通过找到值 𝑥∗ 来恢复 𝑥 mod 𝑞′，其中使用 𝑦′ = 𝑔′𝑥∗ mod 𝑝′ 在 (𝑟, 𝑠) 的验证中成功。对 𝑥∗ 的搜索可以离线完成。原始的 𝑥 mod 𝑞 可以通过收集使用不同的 𝑝′𝑖、𝑞′𝑖 计算的足够多的签名，并使用中国剩余定理 (CRT) 结合不同的份额 𝑥∗ mod 𝑞′𝑖 来完全重构。

在两种情况下，找到 𝑥 mod 𝑞′𝑖 的值会失败：

1. 如果 𝑔′𝑘 mod 𝑝′ 是 𝑞′ 的倍数，那么 𝑟 = 0 mod 𝑞，
2. 如果 𝑔′𝑘 mod 𝑝′ 不是 𝑞′ 的倍数，但 𝑟 = 0 mod 𝑞。 这些情况都会导致无法成功找到 𝑥 mod 𝑞′𝑖。





1. 准备特殊的PGPrime和PGGenerator数值（常数）。
2. 获取给定用户的**Secret Key Packet**结构，并将存储在**Secret Key Packet**内部的**Public Key Packet**中的p、g值替换为p´=PGPrime和g´=PGGenerator。
3. 捕获用户使用这些虚假参数签名的第一个未加密的消息或文件，并保留其签名。
4. 基于获得的消息及其签名，计算用户的私钥（x值）。
5. 将p、g值恢复到原始状态。



**ECC（椭圆曲线）私钥**是一种用于椭圆曲线数字签名算法（ECDSA）的关键部分。让我来解释一下：

1. [**椭圆曲线私钥结构**：RFC 5915定义了椭圆曲线私钥的语法和语义。它包括私钥本身以及相关的参数，有时还包括对应的公钥。这个结构允许生成私钥和公钥的实体分发密钥对和相关的域参数](https://www.rfc-editor.org/rfc/rfc5915)[1](https://www.rfc-editor.org/rfc/rfc5915)。
2. **用途**：椭圆曲线私钥用于生成数字签名，而椭圆曲线公钥用于验证数字签名。例如，当您需要在加密通信中签署或验证消息时，会使用椭圆曲线私钥和公钥。
3. [**私钥大小**：与椭圆曲线密码学一般情况下一样，ECDSA所需的私钥位数大约是安全级别的两倍，以位为单位](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)[2](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)。

如果您还有其他问题，欢迎继续提问！

4.

Copilot

我们首先讨论电子邮件客户端可能存在的脆弱性程度。然后，我们考虑了另外两种使用潜在不安全/对手可访问存储的部署模型。具体来说，我们将看到这些漏洞如何影响了 FlowCrypt 和 ProtonMail。我们将讨论针对这些特定应用程序的具体攻击，以展示我们的攻击思路是如何从孤立的库转化为特定应用程序的。我们的目标是提供一些易受攻击的场景示例，这些场景可能在其他具有类似功能和身份验证逻辑的应用程序中找到。

You

请问FlowCrypt和ProtonMail是什么？

Copilot

**FlowCrypt** 是一款用于加密电子邮件的浏览器插件。它允许用户在使用 Gmail、Outlook 和其他电子邮件服务时对邮件进行端到端加密，以保护邮件内容不被第三方访问。

**ProtonMail** 则是一家总部位于瑞士的安全电子邮件服务提供商。ProtonMail 提供端到端加密，确保用户的电子邮件内容只有发送者和接收者能够解密和阅读。这使得用户的通信更加隐私和安全。

Targeting encrypt-to-self

**针对自我加密的攻击**。除了在第3节中详细介绍的利用秘密密钥操作（签名和解密）的攻击之外，我们还简要描述了另一种攻击向量，该攻击向量利用加密，并且可以针对电子邮件应用程序进行。这是因为电子邮件通常也会使用发送者的密钥进行加密，以便以加密形式存储，同时仍然可以被发送者阅读。该攻击的步骤包括将受害者的公共加密密钥替换为攻击者知道私钥对应的密钥：任何发送的消息都将被加密到恶意密钥，攻击者将能够在拦截消息后解密它。与密钥提取攻击相比，这种自我加密的妥协的一个限制是它只允许访问已发送的消息，而不允许访问已接收的消息（除非发送者在回复时引用了接收到的消息）。此外，在下一段中，我们将解释秘密密钥恢复的影响

Impact of primary key recovery.

在OpenPGP中，即使是仅具有签名功能的主密钥的泄露也可能导致长期的机密性破坏。实际上，如果对手能够获取受害者的主私钥，不仅可以使用它签署消息（冒充受害者），还可以生成新的密钥认证签名。这使得对手可以向受害者的密钥添加加密子密钥并公开宣传它们：由于第三方的认证仍然有效，更新后的密钥将被受害者的信任网络（见第2节）视为合法，其他用户很可能开始将消息加密到恶意的加密子密钥。如果对手能够进行中间人攻击，那么他们可以拦截并访问消息，并将其重新加密到受害者的原始加密子密钥，以避免被检测到。

4.1Email Clients

支持OpenPGP集成的电子邮件客户端通常支持导入现有密钥。根据用户存储密钥的位置（在导入之前），攻击者可能已经能够覆盖它。然后，在客户端中由OpenPGP扩展执行的密钥验证检查缺失的情况下，如果用户没有足够小心地检查密钥指纹，可能会导入损坏的密钥。

**解密预言攻击**在电子邮件客户端环境中实施相当具有挑战性。例如，如果电子邮件的解密和后续渲染由电子邮件客户端自动执行，那么这种攻击可能是可行的。在这种情况下，攻击者可以通过URL加载特定图像（由其控制），并通过监视对应图像URL的访问来确定特定密文是否成功解密。然而，我们的攻击需要处理许多此类电子邮件；相比之下，EFAIL攻击仅需要一个。另一方面，**错误签名攻击**是可行的。为了获得错误的签名，攻击者可能会与受害者发起加密对话：由于OpenPGP消息通常会被签名，受害者在回复消息中很可能会包含签名。

攻击检测和后果：攻击者可以以这样的方式篡改受害者的密钥：即使受害者的解密子密钥没有被移除，受害者仍能解密旧的和新的邮件。但是，受害者之前的签名将无法通过篡改后的密钥验证，因此发送的邮件不会被标记为真实的，但收件箱中的邮件是由发件人签名的。因此，受害者可能不会立即注意到密钥导入存在问题。不过，一旦获取了私钥，攻击者一般无法通过替换已导入的恶意密钥来恢复原始受害者的密钥，所以这种攻击最终可能会被发现。

**EFAIL攻击**是一种针对电子邮件加密系统的攻击，特别是针对使用**OpenPGP**和**S/MIME**协议的加密电子邮件。这种攻击利用了电子邮件客户端在处理加密邮件时的一些漏洞。具体来说，EFAIL攻击的主要目标是获取加密邮件的明文内容，即使攻击者无法直接解密该邮件。

攻击的基本思路如下：

1. 攻击者向受害者发送一个加密邮件，其中包含一个特制的HTML标签或图像。
2. 受害者的电子邮件客户端在渲染这个邮件时会自动解密它。
3. 攻击者可以通过监视电子邮件客户端对特定URL的访问来确定解密是否成功。如果成功，攻击者就能够获取邮件的明文内容。



**短期解决方案**：为了防止这里所呈现的 KO 攻击，实现不应执行私钥操作，除非已经检查了相应公共参数的完整性。这可以通过验证私钥和公钥参数之间的正确关系来实现（因为私钥是通过用于锁定私钥数据包的哈希-然后加密机制进行完整性保护的）。实现这一点需要执行一系列依赖于特定算法的密钥验证步骤；这些步骤不作为 OpenPGP 的一部分进行规定。一些实现确实已经执行了某种形式的密钥验证，但我们审查过的库中没有一个包含足够彻底的检查，以防止我们所描述的所有攻击。在附录 D 中，我们详细介绍了需要执行的每种算法类型的密钥保护步骤。然而，与下面讨论的长期解决方案不同，这些验证过程在防范潜在变体 KO 攻击方面并不具有可证明的安全性，因此只应用于保护遗留密钥。

​    **长期解决方案**：适当的密钥验证相对昂贵，与特定算法相关，并且当前的实现效果不佳。我们认为更好的长期解决方案是使用 AEAD（Authenticated Encryption with Associated Data）以一种与算法无关的方式，在解密时保证完整的密钥完整性。已经在草案 RFC4880bis [19] 中添加了 AEAD 加密的密钥，我们的建议是对现有规范进行小幅扩展，不需要任何额外的加密功能。所需的仅是在创建 AEAD 加密的私钥时，将公钥材料和算法类型包含在关联数据中。AEAD 的标准安全保证确保公钥和算法类型得到完整性保护，并与加密的私钥绑定。我们与 OpenPGP 工作组一起就这个 AEAD 提案进行了合作。它于 2021 年 12 月被添加到密码刷新文档 [20] 中。最后，请注意，在适用于“加密给自己”的攻击（第 4 节中描述）的实现中，如果不信任公共参数，应在使用密钥进行加密之前执行密钥解密（以及对非 AEAD 加密密钥的密钥验证）。



**6 结论** 在本文中，我们研究了针对OpenPGP规范、其实现和使用这些实现的应用程序的关键覆写（KO）攻击。这些攻击可以恢复用户的私钥。特别值得注意的是，现实世界中OpenPGP使用的变化情况扩展了攻击途径，这一途径可以追溯到2001年。 我们看到，在Secret Key数据包中，公共参数与（加密的）私有参数之间缺乏加密绑定，这使得我们的环境中可以进行跨算法攻击，将所有离散对数方案的安全性降低到具有可互换私钥格式的最弱实例的安全性。我们还展示了如何有效地利用覆写公钥参数的能力来攻击DSA和非CRT RSA签名，以及ElGamal和非CRT RSA解密（假设存在一个指示解密成功或失败的单比特侧信道）。在这里，我们基于不同算法、它们的实现以及支持OpenPGP的主要密码库中使用的非标准密钥验证程序的特点，开发了一系列新颖的攻击。我们发现，某些特定库执行的密钥验证程序本身可以被利用来执行KOKV攻击。这突显了OpenPGP规范将确认密钥完整性的任务留给各个实现的危险性。 最后，我们提出了一种简单易行的对抗这类攻击的措施：使用AEAD方案加密Secret Key数据包的私有参数，将公共参数（以及密钥算法）合并到相关数据中。这一对抗措施现已包含在草案OpenPGP密码刷新文档中。 我们还建议在OpenPGP中停用ElGamal加密选项。正如我们的工作和[6]所示，它是一个非常脆弱的选项。          

## **ACM CCS The Best Paper Awards**

2022The Distinguished Paper Award winners for CCS 2022 are:

**Kenny Paterson, Lara Bruseghini, Daniel Huigens**, Victory by KO: Attacking OpenPGP Using Key Overwriting

**Ning Luo, Timos Antonopoulos, William Harris, Ruzica Piskac, Eran Tromer, Xiao Wang**, Proving UNSAT in Zero Knowledge

**Xaver Fabian, Marco Patrignani, Marco Guarnieri**, Automatic Detection of Speculative Execution Combinations

**Samuel Steffen, Benjamin Bichsel, Martin Vechev**, Zapper: Smart Contracts with Data and Identity Privacy

**Alex Davidson, Peter Snyder, E. B. Quirk, Joseph Genereux, Hamed Haddadi, Benjamin Livshits**, STAR: Secret Sharing for Private Threshold Aggregation Reporting













































